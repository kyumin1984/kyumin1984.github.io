[ { "title": "[#15] 람다식", "url": "/posts/java-study-15/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-02-05 10:22:00 +0900", "snippet": "15주차 과제 : 람다식목표 자바의 람다식에 대해 학습하세요.학습할 것 1.람다식 사용법 2.함수형 인터페이스 3.Variable Capture 4.메소드, 생성자 레퍼런스 " }, { "title": "[#14] 제네릭", "url": "/posts/java-study-14/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-02-04 10:22:00 +0900", "snippet": "14주차 과제 : 제네릭목표 자바의 제네릭에 대해 학습하세요.학습할 것 1.제네릭 사용법 2.InputStream과 OutputStream 3.제네릭 주요 개념 (바운디드 타입, 와일드 카드) 4.제네릭 메소드 만들기 5.Erasure " }, { "title": "[#13] I/O", "url": "/posts/java-study-13/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-02-03 10:22:00 +0900", "snippet": "13주차 과제 : I/O목표 자바의 Input과 Ontput에 대해 학습하세요.학습할 것 1.스트림 (Stream) / 버퍼 (Buffer) / 채널 (Channel) 기반의 I/O 2.InputStream과 OutputStream 3.Byte와 Character 스트림 4.표준 스트림 (System.in, System.out, System.err) 5.파일 읽고 쓰기 " }, { "title": "[#12] 애노테이션", "url": "/posts/java-study-12/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-02-02 10:22:00 +0900", "snippet": "12주차 과제 : 애노테이션목표 자바의 애노테이션에 대해 학습하세요.학습할 것 1.애노테이션 정의하는 방법 2.@retention 3.@target 4.@documented 5.애노테이션 프로세서 " }, { "title": "[#11] Enum", "url": "/posts/java-study-11/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-02-01 10:22:00 +0900", "snippet": "11주차 과제 : Enum목표 자바의 열거형에 대해 학습하세요.학습할 것 1.enum 정의하는 방법 2.enum이 제공하는 메소드 (values()와 valueOf()) 3.java.lang.Enum 4.EnumSet " }, { "title": "[#10] 멀티쓰레드 프로그래밍 ", "url": "/posts/java-study-10/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-31 10:22:00 +0900", "snippet": "10주차 과제 : 멀티쓰레드 프로그래밍목표 자바의 멀티쓰레드 프로그래밍에 대해 학습하세요.학습할 것 1.Thread 클래스와 Runnable 인터페이스 2.쓰레드의 상태 3.쓰레드의 우선순위 4.Main 쓰레드 5.동기화 6.데드락 " }, { "title": "[#9] 예외처리", "url": "/posts/java-study-9/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-30 10:22:00 +0900", "snippet": "9주차 과제 : 예외처리목표 자바의 예외 처리에 대해 학습하세요.학습할 것 1.자바에서 예외 처리 방법 (try, catch, throw, throws, finally) 2.자바가 제공하는 예외 계층 구조 3.Exception과 Error의 차이는? 4.Runtime Exception과 RE가 아닌 것의 차이는? 5.커스텀한 예외 만드는 방법 " }, { "title": "[#8] 인터페이스", "url": "/posts/java-study-8/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-29 10:22:00 +0900", "snippet": "8주차 과제 : 패키지목표 자바의 인터페이스에 대해 학습하세요.학습할 것 1.인터페이스 정의하는 방법 2.인터페이스 구현하는 방법 3.인터페이스 레퍼런스를 통해 구현체를 사용하는 방법 4.인터페이스 상속 5.인터페이스의 기본 메소드 (Default Method), 자바 8 6.인터페이스의 static 메소드, 자바 8 7.인터페이스의 private 메소드, 자바 9 " }, { "title": "[#7] 패키지", "url": "/posts/java-study-7/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-27 10:22:00 +0900", "snippet": "7주차 과제 : 패키지목표 자바의 패키지에 대해 학습하세요.학습할 것 1.package 키워드 2.import 키워드 3.클래스패스 4.CLASSPATH 환경변수 5.-classpath 옵션 6.접근지시자 " }, { "title": "[#6] 상속", "url": "/posts/java-study-6/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-27 10:22:00 +0900", "snippet": "6주차 과제 : 상속목표 자바의 상속에 대해 학습하세요.학습할 것 1.자바 상속의 특징 2.super 키워드 3.메소드 오버라이딩 4.다이나믹 메소드 디스패치 (Dynamic Method Dispatch) 5.추상 클래스 6.final 키워드 7.Object 클래스 " }, { "title": "[#5] 클래스", "url": "/posts/java-study-5/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-26 10:22:00 +0900", "snippet": "5주차 과제 : 클래스목표 자바의 Class에 대해 학습하세요.학습할 것 1.클래스 정의하는 방법 2.객체 만드는 방법 (new 키워드 이해하기) 3.메소드 정의하는 방법 4.생성자 정의하는 방법 5.this 키워드 이해하기 " }, { "title": "[#4] 제어문", "url": "/posts/java-study-4/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-25 10:22:00 +0900", "snippet": "4주차 과제 : 제어문목표 자바가 제공하는 제어문을 학습하세요.학습할 것 1.선택문 2.반복문 3.JUnit 5 학습하세요. 4.LinkedList를 구현하세요. 5.Stack을 구현하세요. 6.앞서 만든 ListNode를 사용해서 Stack을 구현하세요. 7.Queue를 구현하세요. " }, { "title": "[#3] 연산자", "url": "/posts/java-study-3/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-24 10:22:00 +0900", "snippet": "3주차 과제 : 연산자목표 자바가 제공하는 다양한 연산자를 학습하세요.학습할 것 1.산술 연산자 2.비트 연산자 3.관계 연산자 4.논리 연산자 5.instanceof 6.assignment(=) operator 7.화살표(-&amp;gt;) 연산자 8.3항 연산자 9.연산자 우선 순위 10.(optional) Java 13. switch 연산자 " }, { "title": "[#2] 자바 데이터 타입, 변수 그리고 배열", "url": "/posts/java-study-2/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-23 10:22:00 +0900", "snippet": "2주차 과제 : 자바 데이터 타입, 변수 그리고 배열목표 자바의 프리미티브 타입, 변수 그리고 배열을 사용하는 방법을 익힙니다.학습할 것 1.프리미티브 타입 종류와 값의 범위 그리고 기본 값 2.프리미티브 타입과 레퍼런스 타입 3.리터럴 4.변수의 스코프와 라이프타임 5.타입 변환, 캐스팅 그리고 타입 프로모션 6.1차 및 2차 배열 선언하기 7.타입 추론, var " }, { "title": "[#1] JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가?", "url": "/posts/java-study-1/", "categories": "Study, Java", "tags": "Java Study, Study", "date": "2021-01-22 10:22:00 +0900", "snippet": "이제와서 갑자기 자바 기초 스터디라니?평소 MicroSoft 에 시니어 개발자로 재직중이신 백기선님의 강의를 인프런에서 듣고 있었고 있었다.유투브 채널도 함께 운영 중이신데, 몇 년전 우연히 유투브에서 영상을 본 후 인프런에 올려주시는강의 대부분을 구매해서 보고 있다. 구입만 하고 시작도 못한 강의들이 수두룩 할뿐… 😭그러던 어느날 백기선님이 자바 기초 스터디를 하신다는 소식을 듣고, 스터디에 참여는 하지 않고매주 토요일에 하는 유투브 라이브만 보고 있었는데, 멤버쉽에 가입하면 지나간 라이브 영상을볼수 있어서 멤버쉽에 가입도 했다. 개발자들끼리 수다떠는게 생각보다 재밌다…😀( 주말 밤에 개발자 유투브 생방을 본다는게... 확실히 나도 평범하진 않은 듯...😱 )“그러던 중 스터디에 참여한 사람들한테 티셔츠를 준다고 한 것이다!”심지어 이미 종료된 과제를 제출 할 수 있어서, 내 의지만 있다면 완주 할 수 있다.유투브 라이브를 보다보면 내 경력이 부끄러울 만큼 모르는게 많다는 걸새삼스레 느끼고 있던 차에 들려온 소식이었다. 티셔츠도 받을 수 있고, 공부의 목표도 생겼다.늦었지만 지금부터 쫓아가려고 과제를 시작 했다.1주차 과제 : JVM은 무엇이며 자바 코드는 어떻게 실행하는 것인가.목표 자바 소스 파일(.java)을 JVM으로 실행하는 과정 이해하기.학습할 것 1.JVM이란 무엇인가 2.컴파일 하는 방법 3.실행하는 방법 4.바이트코드란 무엇인가 5.JIT 컴파일러란 무엇이며 어떻게 동작하는지 6.JVM 구성 요소 7.JDK와 JRE의 차이 1. JVM이란 무엇인가자바 개발자중에 JVM이란 말을 모르는 사람은 없을 것이다. 하지만 설명해 보라고 한다면,과연 얼마나 설명을 할 수 있을까?JVM은 Java Virtual Machine 의 약자로 글자 그대로 자바 가상 머신이다. 자바가 등장 하면서 내세운 슬로건이 Write Once Run Anywhere 였다.한번 작성해서 어디서나 실행 할 수 있다는 얘긴데, 자바 이전의 프로그램 언어들은 프로그램이 실행되는 플랫폼( CPU + OS )에 맞도록별도의 컴파일을 해줘야 했다.윈도우에서 컴파일된 프로그램은 리눅스에서 실행 할 수 없었다는 말이다.하지만 자바는 JVM만 설치 되어있다면 어디서나 실행이 가능 하다.한마디로 자바 프로그램을 어디서나 실행 할 수 있게 도와주는 가상머신이고,크게 Class Loader, Runtime Data Areas, Excution Engine 3가지로 구성되어 있다.2. 컴파일 하는 방법자바로 프로그램을 작성하려면 개발 도구를 설치 해야한다.이게 7번에서 다룰 Java Development Kit 즉 JDK 이다. 메모장이나 IDE 에서 자바 코드로프로그램을 작성하면 .java 파일이 생성 되는데, 이 상태에서는 바로 실행 할 수가 없다.작성한 .java 파일을 설치된 JDK 폴더의 /bin/javac.exe 파일로 컴파일 할 수가 있다.컴파일을 하면 .class 파일이 생성되고 JVM에선 .class 파일을 로딩하게 된다.public class HelloWorld { public static void main(String[] args){ System.out.println(&quot;Hello World!&quot;); }}터미널에서 javac HelloWorld.java 를 실행하면 아래 그림 처럼 HelloWorld.class 파일이 생성된다.3. 실행하는 방법javac로 컴파일되어 생성된 .class 파일은 java 명령어로 실행한다.위 그림 처럼 터미널에서 java HelloWorld 를 실행하게 되면 Hello World! 가 출력 된 것을 확인 할 수 있다.4. 바이트코드란 무엇인가java 코드로 작성된 .java 파일을 javac로 컴파일 하면 .class 파일이 생성되는 것은위에서 확인을 했는데,이때 생성된 클래스 파일이 바이트 코드로 작성 되어있다.바이트 코드(.class)는 JVM이 이해하는 코드인 것이다.javap -c 클래스파일명으로 아래 그림 처럼 확인 할 수 있다.바이트 코드 확인은 저렇게 한다고만 알면 될 것 같다. 저걸 또 공부하기엔… 😱5. JIT 컴파일러란 무엇이며 어떻게 동작하는지컴파일된 바이트 코드 (.class 파일)는 클래스 로더(Class Loader) 에 의해서 JVM 내로 로드 되고,실행 엔진(Excution Engine) 에 의해서 기계어로 해석 되어 실행 데이터 영역(Runtime Data Areas)에배치된다. 이때 실행 엔진에 인터프리터와 JIT(Just In Time) 컴파일러가 있다.로드된 바이트 코드를 인터프리터가 한줄씩 읽어서 바이트 코드를 기계어로 해석을 하는데,이때 중복된 코드를 해석하는 단점이 있는데, JIT 컴파일러는 이러한 단점을 보완하기 위해해석한 내용을 캐싱해서 중복된 내용에 대해서 빠르게 수행한다.출처:https://img1.daumcdn.net/thumb/R1280x0/?scode=mtistory2&amp;amp;fname=https%3A%2F%2Fblog.kakaocdn.net%2Fdn%2FbFV3Wt%2FbtqG68RvEaq%2FdUMj5kiqu5Zb0iEIxTGnCK%2Fimg.png 6. JVM 구성 요소출처:https://miro.medium.com/max/700/1*slIuYO633BCuBh_gfYRmGg.png Class LoaderRuntime 시점에 클래스를 로딩하게 해주며 클래스의 인스턴스를 생성하면 클래스 로더를 통해 메모리에 로드하게 된다. Runtime Data AreasJVM이 프로그램을 수행하기 위해 OS로 부터 별도로 할당 받은 메모리 공간을 말하며, 크게 5가지 영역으로 나눌 수 있다.출처:https://hongsii.github.io/2018/12/20/jvm-memory-structure/ Method Area - 모든 쓰레드가 공유하는 메모리 영역(클래스, 인터페이스, 메소드, 필드, Static 변수등의 바이트 코드 등을 보관) Heap Area - 런타임시 동적으로 할당하여 사용하는 영역 Class를 통해 Instance를 생성하면 Heap에 저장됨 Stack Area - Thread가 시작될 때 생성되며 Method와 Method 정보 저장 PC Register - CPU가 Instruction을 수행하는 동한 필요한 정보를 저장 Native Method Stack - Java 이외의 언어로 작성된 native 코드를 위한 Stack(JNI) Execution EngineLoad된 Class의 Byte Code를 실행하는 Runtime Module이 바로 Execution Engine이다.Class Loader를 통해 jvm 내의 Runtime Data Areas에 배치된 바이트 코드는 Execution Engine에 의해 실행된다. 인터프리터 JIT 컴파일러 Garbage CollectorGarbage Collector(GC)는 Heap 메모리 영역에 생성된 객체들 중에 참조되지 않은 객체들을 제거하는 역할을 한다. GC의 동작시간은 일정하게 정해져 있지 않기 때문에 언제 객체를 정리할지는 알 수 없다. 즉 바로 참조가 없어지자마자 작동하는 것이 아니라는 것이다. 또한 GC를 수행하는 동안 GC Thread를 제외한 다른 모든 Thread는 일시정지상태가 된다.특히, Full GC가 일어나는 수초간 모든 Thread가 정지한다면 심각한 장애로 이어질 수 있다. 최초 JVM이 나왔을때 Interpreter(한 줄씩 해석하고 실행) 이였기 때문에 속도가 느리다는 단점이 있었지만 JIT Compiler (Just In Time) 방식을 통해 이 점을 보완해왔다.JIT는 Byte Code를 어셈블러 같은 Native Code로 바꿔서 실행이 빠르지만 역시 변환하는데 비용이 발생한다. 이 같은 이유 때문에 JVM은 모든 코드를 JIT Compiler 방식으로 실행하지 않고,Interpreter 방식을 사용하다 일정 기준이 넘어가면 JIT Compiler 방식으로 실행한다. 7. JDK와 JRE의 차이 JDK ( Java Development Kit )자바 개발 도구로 자바를 개발하기 위해선 JDK를 설치해야 한다. 개발에 필요한 여러가지 툴이 포함된다. JRE ( Java Runtime Environment )자바 실행 환경으로 자바로 작성된 프로그램을 실행하기 위해선 JRE를 설치해야 한다.출처:https://cryptosalamander.tistory.com/4 " }, { "title": "Map과 HashMap의 차이점은 무엇인가요?", "url": "/posts/java-map-hashmap-diffrent/", "categories": "Interview", "tags": "Collection Framework, Map, HashMap", "date": "2021-01-03 18:32:00 +0900", "snippet": " Map과 HashMap의 차이점은 무엇인가요?몇 년전 모회사에 면접 보러 갔을 때 1차 기술면접 자리에서 면접관이 나에게 했던 질문이었다.순간 나는 “Map 인터페이스를 구현한 클래스가 HashMap 입니다.” 라고 대답을 했는데,면접관은 아무런 말도 없이 고개만 끄덕였고 지금 생각해봐도 저걸 왜 물어봤는지 도무지 모르겠다.설마 저 대답을 원한건 아니었기를… 횡설수설한 기억 뿐인 면접이었지만 의외로 1차는 합격을 했고,최종 2차에서 떨어졌다. 😱“그럼 HashMap 은 어떻게 동작하나요?”만약 이후 질문이 저랬다면 버벅대다 대답도 못했을 테지….. 😭HashMap의 동작에 대해서는 추후에 자세히 다룰 예정이다.참고로 유투브 포프TV 를 운영하시는 포프님은 개발자의 기본기를 HashTable 이라고 말씀하시면서,개발자 면접때 물어본다고 하셨다.다시 주제로 돌아가서 Map은 Collection Framework에 속한 인터페이스중 하나로 키와 값을 하나의 쌍으로묶어서 저장하는 자료 구조 이다.( Collection Framework 란 다수의 데이터를 처리하는 자료 구조를 통칭하는 개념이다.)키의 중복을 허용하지 않는다는 것이 Map의 핵심.이러한 Map을 구현한 클래스중에 하나가 HashMap 이다. 이외에도 HashTable, HashMap, ConcurrentHashMap, LinkedHashMap, TreeMap 등이 있다.HashTable은 Java 1.0 부터 있던 API 이고, HashMap은 Java 1.2 에서 추가된 API 이다.비슷한 이름을 가진 두 녀석, HashTable 과 HashMap의 차이점을 살펴보면, 비교 HashTable HashMap Synchronized Y N Thread-Safe Y N Null Key N Y Null Value N Y Multi-Thread 환경이 아니라면 Synchronized가 없는 HashMap을 쓰는 것이 아무래도 성능상 이롭다.그러나 Synchronized 가 필요한 상황일지라도 HashTable은 오래된 클래스라서 최근에는 사용하지 않고,ConcurrentHashMap 라는 HashMap에서 Synchronized가 추가된 클래스를 사용하길 권장한다.하지만 Multi-Thread 환경에서 개발 해본 적이 없어서 써본적은 없다. 사실 포스팅하면서 처음 봤다… 😱자 이제 설명은 됐고, 코드를 보자. Map&amp;lt;String,String&amp;gt; hashMap = new HashMap&amp;lt;&amp;gt;(); hashMap.put(&quot;white&quot;,&quot;흰색&quot;); hashMap.put(&quot;red&quot;,&quot;빨강&quot;); hashMap.put(&quot;yellow&quot;,&quot;노랑&quot;); hashMap.put(&quot;green&quot;,&quot;녹색&quot;); hashMap.put(&quot;blue&quot;,&quot;파랑&quot;); hashMap.put(&quot;pink&quot;,&quot;핑크&quot;); for(String key : hashMap.keySet()){ System.out.println(&quot;key is : &quot; + key + &quot;, value is : &quot; + hashMap.get(key)); }출력 결과// key is : red, value is : 빨강// key is : pink, value is : 핑크// key is : green, value is : 녹색// key is : white, value is : 흰색// key is : blue, value is : 파랑// key is : yellow, value is : 노랑결과값을 보면 입력한 순서대로 출력되면 좋겠지만 뒤죽박죽으로 출력이 된다.이럴때 필요한게 TreeMap, LinkedHashMap 이 있다. 위에 얘기했던 면접때 LinkedHashMap 에 대한질문도 있었는데, 창피하게도 제대로 대답은 못했고 안써봐서 잘 모른다고 했다. 일할때도 ArrayList&amp;lt;HashMap&amp;gt; 형태로만 써왔고, 왜 쓰는지에 대해선 생각해본적 없었다.그냥 남들이 쓰니까 썼다. 역시 모르면 물어봐야한다.돌이켜보면 LinkedHashMap 보다 성능상 나아서 다들 그렇게 썼나보다 라고 생각하고 싶지만,왠지 그들도 모르고 그냥 쓴 것 같다……. 😰순서를 보장하는 TreeMap 과 LinkedHashMap.정확하게 얘기 하면 LinkedHashMap는 입력된 순서를 보장하고, TreeMap는 정렬된 순서를 보장한다. Collections.sort에 Compartor 구현으로 순서를 변경 할 수 있다.기본 정렬 순서는 숫자 &amp;gt; 알파벳 대문자 &amp;gt; 알파벳 소문자 &amp;gt; 한글 순이다.(TreeMap은 내부적으로 Red-Black Tree로 저장한다. Red-Black Tree 대해서는 나중에 다시 정리 할 예정.)자 이제 설명은 됐고, 코드를 보자. Map&amp;lt;String,String&amp;gt; linkedHashMap = new LinkedHashMap&amp;lt;&amp;gt;(); linkedHashMap.put(&quot;white&quot;,&quot;흰색&quot;); linkedHashMap.put(&quot;red&quot;,&quot;빨강&quot;); linkedHashMap.put(&quot;yellow&quot;,&quot;노랑&quot;); linkedHashMap.put(&quot;green&quot;,&quot;녹색&quot;); linkedHashMap.put(&quot;blue&quot;,&quot;파랑&quot;); linkedHashMap.put(&quot;pink&quot;,&quot;핑크&quot;); for(String key : linkedHashMap.keySet()){ System.out.println(&quot;key is : &quot; + key + &quot;, value is : &quot; + hashMap.get(key)); }출력 결과// key is : white, value is : 흰색// key is : red, value is : 빨강// key is : yellow, value is : 노랑// key is : green, value is : 녹색// key is : blue, value is : 파랑// key is : pink, value is : 핑크출력결과를 보면 입력된 순서가 보장됨을 확인 할 수 있다.LinkedHashMap 은 Doubly-Linked List를 내부에 유지함으로써 입력된 자료의 순서를 보장한다.그리고 이번 포스팅에선 대략적인 내용만 정리하고 동작 방법이나 성능 등 자세한 포스팅은 나중에 다룬다.앞으로도 면접 때 들었던 질문을 꾸준히 포스팅 할 예정이다. 👌" }, { "title": "Keep Alive 에 대해 설명해보세요.", "url": "/posts/webserver-apache-keep-alive/", "categories": "Interview", "tags": "Http Protocol, Web Server, Apache", "date": "2019-08-12 10:22:00 +0900", "snippet": " Keep Alive 에 대해 설명 해줄 수 있나요?“아 그거 Apache 설정에서 봤는데 정확히는 잘 모르겠습니다.”서버에 Apache 설치는 몇번 해봤었는데, 그때 httpd.conf 파일에서 봤던 옵션이었다.Keep Alive 설정을 이야기 하기 전에 HTTP 얘기를 먼저 해야겠다. HTTP는 무상태(stateless), 비연결성(connectionless)의 특징을 가진다.무상태(stateless)데이터를 주고 받기 위한 각각의 데이터 요청이 서로 독립적으로 관리가 된다는 말로, 이전의 데이터 요청과 다음의 데이터 요청은 서로 관련이 없다는 말이다.비연결성(connectionless)이 비연결성이 Keep Alive 와 관련이 있는 특징인데, HTTP는 연결을 매번 끊고 새로 생성하는 구조로설계되어 Network 비용 측면에서 많은 비용을 소비하는 구조 이다. 이에 대한 해결책으로 Keep Alive 라는기능을 HTTP 1.1 부터 지원 했다. Keep Alive는 max / timeout 2개의 속성이 있는데timeout 하나의 연결이 유지되는 시간(초)이고 max 는 하나의 연결이 끝나기 전까지 요청 할 수 있는 최대 요청 수이다.Keep-Alive: max=5, timeout=120 처럼 설정을 하면 한번 요청된 연결은 120초 동안 유지 되고, 연결이 종료되기 전까지 최대 5번의 요청까지 허용한다는 이야기다.timeout 시간을 초과하거나, max 값을 초과하면 연결은 끊어지고 새로운 연결이 생성된다.요청(request)의 응답(response) 데이터는 아래처럼 내려온다.e.g.)~$ curl -I https://www.domain.com/file.htmlHTTP/1.1 200 OKConnection: Keep-AliveContent-Type: text/html; charset=UTF-8Date: Thu, 15 Jan 2015 16:45:29 GMTContent-Length: 1845Keep-Alive: timeout=5, max=120Server: Apache/2.4.9 (Unix) PHP/5.6.2이번글은 여기까지만 알아보자." }, { "title": "ASCII, Unicode, UTF-8 란?", "url": "/posts/ascii-unicode-utf8/", "categories": "Interview", "tags": "UTF-8, Encoding", "date": "2019-07-12 10:22:00 +0900", "snippet": " ASCII는 American Standard Code for Information Interchange의 약자로ANSI라는 미국 국립 표준 협회에서 표준화한 정보교환용 7비트 부호 체계이다.컴퓨터는 2진수로 표현을 한다면서 갑자기 7 bit 가 왜 나와?1 byte 를 구성하는 8 bit 중에 7 bit 만 쓰는 이유는 나머지 1 bit 는 에러검출용 비트(패리티비트)로사용하기 때문이다. 7 bit는 2 7 이라서 128개 ( 0 ~ 127 ) 를 표현 할 수 있다.아래 그림처럼 0 ~ 127 까지 고유한 값이 할당 되어있는걸 알 수 있다.ASCII 코드는 영문을 표시하기에는 부족함이 없었지만 다른 언어를 표현하기에7 bit 로는 부족했고 이를 극복하기 위해 1 bit 를 확장한 8 bit 의 ASCII 코드가 나왔는데이것이 바로 ANSI 코드 이다. 8 bit 는 2 8 즉 256개를 표현 할 수 있다.하지만 여전히 한국,중국,일본등의 글자를 표현하기에는 제한이 있었고,이에 2 byte (16 bit) 로 확장한 UNICODE가 등장했다.16 bit는 2 16 즉 65536개를 표현 할 수 있다. Unicode는 Universal Coded Character Set의 약자로서 문자를 16bit의 숫자로 표현한 것여기까지 정리하면 ASCII, ANSI Code, Unicode는 표현할수 있는 문자의 가지수가 다른1:1로 매핑된 문자집합 이다.위 ASCII Table과 같이 Unicode Table 은 링크에서 확인 할 수있다.그래서 UTF-8은 뭐냐고?UTF-8을 얘기하기 전에 Encoding(인코딩)을 먼저 알아야 하는데,인코딩이란 문자나 기호들의 집합을 컴퓨터에 저장하거나 통신에 사용할 목적으로부호화 하는 방법을 말한다. 이러한 인코딩의 반대 개념으로 Decoding(디코딩)이 있는데부호화된 정보를 부호화되기 전으로 되돌리는 처리방식으로 복호화라고 한다.Encoding(부호화) &amp;lt;-&amp;gt; Decoding(복호화) 여기서 부호화를 수행하는 장치나 회로, 소프트웨어 및 알고리즘을 인코더라고 이야기 하고, 복호화를 수행해주는것을 디코더라고 한다.인코딩과 디코딩을 하는 이유는 위에서 이야기한 표준화된 문자집합을 사용하기 위함이다.표준화된 데이터 표현 방법이 없다면 데이터를 주고 받을때 호환성이 떨어진다.아니 그래서 UTF-8은 언제 얘기 할꺼냐고?Unicode는 2 byte 로 표현하기 때문에 1 byte 만으로도 충분한 영어권 사용자들은메모리가 2배로 낭비 된다. 따라서 문자에 따라서 1 ~4 byte 가변길이로 인코딩 하는UTF-8 이 탄생했다. UTF-8은 Universal Coded Character Set + Transformation Format – 8-bit 의 약자이다.UTF-8 의 경우 숫자/영문은 1 byte 로 처리하고한글은 초성, 중성, 종성을 각각 1 byte 조합형으로도합 3 byte 로 처리한다.UTF-8은 8 bit 단위로 처리하고, UTF-16은 16 bit 단위로 처리하고, UTF-32은 32 bit 단위로 처리한다.대게 UTF-8로 사용하고 있으니 16,32 는 개념정도만 알고 있으면 된다.어디선가 한번쯤 들어봤을 EUC-KR은 완성형 인코딩 방식으로 한글을 2 byte로 표현한다.복잡하게 들어가면 끝도 없으니 이정도로 마무리한다." } ]
